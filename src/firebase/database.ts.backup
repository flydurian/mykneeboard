import { ref, get, set, push, update, remove, onValue, off } from "firebase/database";
import { database, auth } from "./config";
import { getAuth, onAuthStateChanged } from "firebase/auth";

// 안전한 숫자 변환 함수 (NaN 방지)
const safeParseInt = (value: string): number => {
  // 숫자로만 구성된 문자열인지 확인
  if (/^\d+$/.test(value)) {
    return parseInt(value);
  }
  
  // 숫자가 아닌 경우 해시 기반 숫자 생성
  let hash = 0;
  for (let i = 0; i < value.length; i++) {
    const char = value.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash; // 32비트 정수로 변환
  }
  return Math.abs(hash);
};

// 데이터 읽기
export const readData = async (path: string) => {
  try {
    const dataRef = ref(database, path);
    const snapshot = await get(dataRef);
    return snapshot.exists() ? snapshot.val() : null;
  } catch (error) {
    console.error("Error reading data:", error);
    throw error;
  }
};

// 데이터 쓰기
export const writeData = async (path: string, data: any) => {
  try {
    const dataRef = ref(database, path);
    await set(dataRef, data);
    return true;
  } catch (error) {
    console.error("Error writing data:", error);
    throw error;
  }
};

// 데이터 추가 (자동 키 생성)
export const pushData = async (path: string, data: any) => {
  try {
    // console.log('pushData called with:', { path, data });
    
    const dataRef = ref(database, path);
    // console.log('Database reference created for path:', path);
    
    const newRef = push(dataRef);
    // console.log('New reference created:', newRef.key);
    
    await set(newRef, data);
    // console.log('Data set successfully');
    
    return newRef.key;
  } catch (error) {
    console.error("Error pushing data:", error);
    console.error("Error details:", {
      code: error.code,
      message: error.message,
      path: path
    });
    throw error;
  }
};

// 데이터 업데이트
export const updateData = async (path: string, data: any) => {
  try {
    const dataRef = ref(database, path);
    await update(dataRef, data);
    return true;
  } catch (error) {
    console.error("Error updating data:", error);
    throw error;
  }
};

// 데이터 삭제
export const deleteData = async (path: string) => {
  try {
    const dataRef = ref(database, path);
    await remove(dataRef);
    return true;
  } catch (error) {
    console.error("Error deleting data:", error);
    throw error;
  }
};

// 실시간 데이터 리스너
export const subscribeToData = (path: string, callback: (data: any) => void) => {
  const dataRef = ref(database, path);
  onValue(dataRef, (snapshot) => {
    const data = snapshot.exists() ? snapshot.val() : null;
    callback(data);
  });
  
  // 구독 해제 함수 반환
  return () => off(dataRef);
};



// 사용자별 월별 데이터 경로 생성 함수
const getMonthPath = (date: string, userId: string) => {
  const dateObj = new Date(date);
  const year = dateObj.getFullYear();
  const month = dateObj.getMonth() + 1; // 0-based to 1-based
  return `users/${userId}/flights/${year}/${month.toString().padStart(2, '0')}`;
};

// 사용자의 모든 월의 비행 데이터 가져오기
export const getAllFlights = async (userId: string) => {
  try {
    if (!userId) {
      return [];
    }
    
    // 현재 인증 상태 확인
    const currentUser = auth.currentUser;
    
    if (!currentUser) {
      return [];
    }
    
    if (currentUser.uid !== userId) {
      return [];
    }
    
    const allFlightsRef = ref(database, `users/${userId}/flights`);
    
    const snapshot = await get(allFlightsRef);
    
    if (!snapshot.exists()) {
      return [];
    }
    
    const allFlights: any[] = [];
    const yearData = snapshot.val();
    
    // 모든 연도와 월을 순회 (안전한 구조 검증 추가)
    Object.keys(yearData).forEach(year => {
      if (yearData[year] && typeof yearData[year] === 'object') {
        Object.keys(yearData[year]).forEach(month => {
          const monthFlights = yearData[year][month];
          if (monthFlights && typeof monthFlights === 'object') {
            Object.keys(monthFlights).forEach(flightKey => {
              const flightData = monthFlights[flightKey];
              if (flightData && typeof flightData === 'object') {
                // id 필드가 없거나 유효하지 않은 경우 안전한 숫자 변환 사용
                const flightId = flightData.id && typeof flightData.id === 'number' && !isNaN(flightData.id) && flightData.id > 0 
                  ? flightData.id 
                  : safeParseInt(flightKey);
                
                allFlights.push({
                  ...flightData,
                  id: flightId
                });
              }
            });
          }
        });
      }
    });
    

    return allFlights.sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());
  } catch (error) {
    console.error('Error getting all flights:', error);
    console.error('Error details:', {
      code: error.code,
      message: error.message,
      userId: userId
    });
    
    // 권한 오류인 경우 빈 배열 반환
    if (error.code === 'PERMISSION_DENIED') {
      console.log('Permission denied, returning empty array');
      return [];
    }
    
    throw error;
  }
};

// 사용자의 특정 월의 비행 데이터 가져오기
export const getFlightsByMonth = async (year: number, month: number, userId: string) => {
  const monthPath = `users/${userId}/flights/${year}/${month.toString().padStart(2, '0')}`;
  const monthFlightsData = await readData(monthPath);

  if (!monthFlightsData) {
    return []; // 데이터가 없으면 빈 배열 반환
  }

  // Firebase 객체를 배열로 변환하면서 각 항목에 ID 부여 (안전한 구조 검증 추가)
  const monthFlightsArray: any[] = Object.keys(monthFlightsData).map(flightKey => {
    const flightData = monthFlightsData[flightKey];
    if (flightData && typeof flightData === 'object') {
      const flightId = flightData.id && typeof flightData.id === 'number' && !isNaN(flightData.id) && flightData.id > 0 
        ? flightData.id 
        : safeParseInt(flightKey);
      
      return {
        ...flightData,
        id: flightId
      };
    }
    return null;
  }).filter(Boolean); // null 값 제거

  return monthFlightsArray;
};

// 비행 데이터 추가 (사용자별 월별로 자동 분류)
export const addFlight = async (flightData: any, userId: string) => {
  const monthPath = getMonthPath(flightData.date, userId);
  const newKey = await pushData(monthPath, flightData);
  
  // 생성된 키를 id 필드로 저장 (안전한 숫자 변환 사용)
  if (newKey) {
    const flightRef = ref(database, `${monthPath}/${newKey}`);
    const safeId = safeParseInt(newKey);
    // console.log('addFlight - 생성된 키:', newKey, '변환된 ID:', safeId);
    await update(flightRef, { id: safeId });
  }
  
  return newKey;
};

// 비행 데이터 업데이트 (이륙/착륙 상태만)
export const updateFlight = async (flightId: string, dataToUpdate: any, userId: string) => {
  // 디버깅을 위한 로그 추가
  /*
  console.log('updateFlight 호출:', {
    flightId,
    dataToUpdate,
    userId
  });
  */

  // ✨ 전달받은 dataToUpdate를 그대로 사용합니다
  // console.log('전달받은 업데이트 데이터:', JSON.stringify(dataToUpdate, null, 2));

  // 모든 월에서 해당 비행을 찾아서 업데이트
  const allFlightsRef = ref(database, `users/${userId}/flights`);
  const snapshot = await get(allFlightsRef);
  
  if (snapshot.exists()) {
    const yearData = snapshot.val();
    let found = false;
    
    for (const year of Object.keys(yearData)) {
      if (yearData[year] && typeof yearData[year] === 'object') {
        for (const month of Object.keys(yearData[year])) {
          const monthFlights = yearData[year][month];
          if (monthFlights && typeof monthFlights === 'object') {
            // Firebase 키로 순회하면서 ID 필드로 매칭
            for (const firebaseKey of Object.keys(monthFlights)) {
              const existingFlightData = monthFlights[firebaseKey];
              if (existingFlightData && typeof existingFlightData === 'object') {
                const flightIdNum = existingFlightData.id && typeof existingFlightData.id === 'number' && !isNaN(existingFlightData.id) && existingFlightData.id > 0 
                  ? existingFlightData.id 
                  : safeParseInt(firebaseKey);
                
                // ID가 일치하는 항공편 찾기
                if (flightIdNum.toString() === flightId) {
                  // console.log('찾은 비행 데이터:', JSON.stringify(existingFlightData, null, 2));
                  
                  // ✨ 전달받은 dataToUpdate를 그대로 업데이트합니다
                  const flightRef = ref(database, `users/${userId}/flights/${year}/${month}/${firebaseKey}`);
                  await update(flightRef, dataToUpdate);
                  // console.log(`Firebase 업데이트 성공: 키=${firebaseKey}, ID=${flightId}`);
                  found = true;
                  break;
                }
              }
            }
          }
        }
        if (found) break;
      }
      if (found) break;
    }
    
    if (!found) {
      console.error(`항공편을 찾을 수 없음: ID=${flightId}`);
      throw new Error(`항공편을 찾을 수 없습니다: ${flightId}`);
    }
  }
};

// 비행 데이터 삭제
export const deleteFlight = async (flightId: string, date: string, userId: string) => {
  const monthPath = getMonthPath(date, userId);
  return await deleteData(`${monthPath}/${flightId}`);
};

// 여러 비행 데이터 일괄 추가
export const addMultipleFlights = async (flights: any[], userId: string) => {
  try {
    const promises = flights.map(flight => addFlight(flight, userId));
    const results = await Promise.all(promises);
    return results;
  } catch (error) {
    console.error('Error adding multiple flights:', error);
    throw error;
  }
};

// 사용자의 모든 월의 실시간 구독
export const subscribeToAllFlights = (callback: (flights: any[]) => void, userId: string) => {
  const allFlightsRef = ref(database, `users/${userId}/flights`);
  onValue(allFlightsRef, (snapshot) => {
    if (!snapshot.exists()) {
      callback([]);
      return;
    }
    
    const allFlights: any[] = [];
    const yearData = snapshot.val();
    
    Object.keys(yearData).forEach(year => {
      if (yearData[year] && typeof yearData[year] === 'object') {
        Object.keys(yearData[year]).forEach(month => {
          const monthFlights = yearData[year][month];
          if (monthFlights && typeof monthFlights === 'object') {
            Object.keys(monthFlights).forEach(flightKey => {
              const flightData = monthFlights[flightKey];
              if (flightData && typeof flightData === 'object') {
                // id 필드가 없거나 유효하지 않은 경우 안전한 숫자 변환 사용
                const flightId = flightData.id && typeof flightData.id === 'number' && !isNaN(flightData.id) && flightData.id > 0 
                  ? flightData.id 
                  : safeParseInt(flightKey);
                
                // console.log('subscribeToAllFlights - 키:', flightKey, '변환된 ID:', flightId);
                
                allFlights.push({
                  ...flightData,
                  id: flightId
                });
              }
            });
          }
        });
      }
    });
    
    /*
    console.log('subscribeToAllFlights - 처리된 비행 데이터:', allFlights.map(f => ({
      id: f.id,
      flightNumber: f.flightNumber,
      date: f.date
    })));
    */
    
    const sortedFlights = allFlights.sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());
    // console.log("실시간 데이터 업데이트!", sortedFlights);
    callback(sortedFlights);
  });
  
  return () => off(allFlightsRef);
};

// 사용자의 특정 월의 실시간 구독
export const subscribeToFlightsByMonth = (year: number, month: number, callback: (flights: any) => void, userId: string) => {
  const monthPath = `users/${userId}/flights/${year}/${month.toString().padStart(2, '0')}`;
  return subscribeToData(monthPath, callback);
};

// 기존 함수들 (하위 호환성을 위해 유지)
export const getFlights = async (userId: string) => {
  return await getAllFlights(userId);
};

export const subscribeToFlights = (callback: (flights: any) => void, userId: string) => {
  return subscribeToAllFlights(callback, userId);
};
